#!/usr/bin/env python3
"""
Generate code from XML and test via curl request
"""

import json
import subprocess

# The generated code from simple_gpt_example.xml
test_code = """# Neural VM Experiment: simple_gpt
# Generated by Neural VM Builder

import numpy as np
import torch
import torch.nn as nn
from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass, field
import time

# Atomic Components (placeholder implementations)
class SimpleLinearAtom(nn.Module):
    def __init__(self, in_features, out_features, bias=True):
        super().__init__()
        self.linear = nn.Linear(in_features, out_features, bias=bias)
    def forward(self, x): return self.linear(x)

class SimpleAttentionAtom(nn.Module):
    def __init__(self, embed_dim, num_heads):
        super().__init__()
        self.attn = nn.MultiheadAttention(embed_dim, num_heads, batch_first=True)
    def forward(self, x): return self.attn(x, x, x)[0]

class EmbeddingAtom(nn.Module):
    def __init__(self, vocab_size, embed_dim):
        super().__init__()
        self.embed = nn.Embedding(vocab_size, embed_dim)
    def forward(self, x): return self.embed(x.long())

class PositionalEncodingAtom(nn.Module):
    def __init__(self, max_len, embed_dim):
        super().__init__()
        self.max_len = max_len
        self.embed_dim = embed_dim
        pe = torch.zeros(max_len, embed_dim)
        position = torch.arange(0, max_len, dtype=torch.float).unsqueeze(1)
        div_term = torch.exp(torch.arange(0, embed_dim, 2).float() * (-np.log(10000.0) / embed_dim))
        pe[:, 0::2] = torch.sin(position * div_term)
        pe[:, 1::2] = torch.cos(position * div_term)
        self.register_buffer('pe', pe.unsqueeze(0))
    def forward(self, x): return x + self.pe[:, :x.size(1), :]

class LayerNormAtom(nn.Module):
    def __init__(self, normalized_shape):
        super().__init__()
        self.ln = nn.LayerNorm(normalized_shape)
    def forward(self, x): return self.ln(x)

class ActivationAtom(nn.Module):
    def __init__(self, activation_type='relu'):
        super().__init__()
        self.act = nn.GELU() if activation_type == 'gelu' else nn.ReLU()
    def forward(self, x): return self.act(x)

class AddAtom(nn.Module):
    def __init__(self): super().__init__()
    def forward(self, x, y=None): return x + y if y is not None else x

class DropoutAtom(nn.Module):
    def __init__(self, dropout_rate=0.1):
        super().__init__()
        self.dropout = nn.Dropout(dropout_rate)
    def forward(self, x): return self.dropout(x)

# Setup
input_tokens = np.random.randint(0, 1000, (1, 10))

# Component definitions
embedding = EmbeddingAtom(50257, 512)
pos_encoding = PositionalEncodingAtom(512, 512)
attention = SimpleAttentionAtom(512, 8)
add1 = AddAtom()
attn_norm = LayerNormAtom(512)
ffn_linear1 = SimpleLinearAtom(512, 2048, True)
ffn_activation = ActivationAtom('gelu')
ffn_linear2 = SimpleLinearAtom(2048, 512, True)
add2 = AddAtom()
ffn_norm = LayerNormAtom(512)
dropout = DropoutAtom(0.1)
final_norm = LayerNormAtom(512)
output_projection = SimpleLinearAtom(512, 50257, False)

# Execution
embedded = embedding(torch.from_numpy(input_tokens))
x = pos_encoding(embedded)
attn_out = attention(x)
x_residual = add1(x, attn_out)
x = attn_norm(x_residual)
ffn_out = ffn_linear1(x)
ffn_out = ffn_activation(ffn_out)
ffn_out = ffn_linear2(ffn_out)
x_residual = add2(x, ffn_out)
x = ffn_norm(x_residual)
x = dropout(x)
x = final_norm(x)
logits = output_projection(x)

print('Experiment simple_gpt completed successfully!')
print(f'Output shape: {logits.shape}')
"""

# Save payload to file
payload = {"code": test_code}
with open('C:/neural_vm_experiments/web_interface/curl_payload.json', 'w') as f:
    json.dump(payload, f)

print("Testing XML execution via curl...")
print("=" * 60)

# Run curl command
result = subprocess.run([
    'curl', '-X', 'POST',
    'http://localhost:5000/execute',
    '-H', 'Content-Type: application/json',
    '-d', f'@C:/neural_vm_experiments/web_interface/curl_payload.json'
], capture_output=True, text=True)

print(result.stdout)
if result.stderr:
    print("Stderr:", result.stderr)

# Parse and display result
try:
    response = json.loads(result.stdout)
    if response.get('success'):
        print("\n[SUCCESS] Execution successful!")
        print(f"Execution time: {response.get('execution_time')}s")
        if response.get('stdout'):
            print(f"\nOutput:\n{response.get('stdout')}")
    else:
        print("\n[FAILED] Execution failed!")
        print(f"Error: {response.get('error', 'Unknown error')}")
except json.JSONDecodeError:
    print("[ERROR] Failed to parse response")